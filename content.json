{"meta":{"title":"WBHAN","subtitle":"Coding is fantistic!","description":"Coding is fantistic, so I should record it.","author":"Bohan Wang","url":"http://wangbohan2000.github.io","root":"/"},"pages":[{"title":"","date":"2020-08-11T06:45:43.255Z","updated":"2020-08-11T06:45:43.255Z","comments":true,"path":"404.html","permalink":"http://wangbohan2000.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-11T06:26:49.000Z","updated":"2020-08-11T10:20:33.246Z","comments":false,"path":"categories/index.html","permalink":"http://wangbohan2000.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-11T06:24:31.000Z","updated":"2020-08-11T10:20:33.247Z","comments":false,"path":"tags/index.html","permalink":"http://wangbohan2000.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Jetbrains系列IDE配合Docker插件自动部署","slug":"Jetbrains系列IDE配合Docker插件自动部署","date":"2020-04-10T03:33:11.000Z","updated":"2020-08-11T12:36:22.378Z","comments":true,"path":"2020/04/10/Jetbrains系列IDE配合Docker插件自动部署/","link":"","permalink":"http://wangbohan2000.github.io/2020/04/10/Jetbrains%E7%B3%BB%E5%88%97IDE%E9%85%8D%E5%90%88Docker%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Jetbrains系列IDE配合Docker插件自动部署&nbsp;&nbsp;&nbsp;&nbsp;docker大大简化了部署的复杂度，可是大家日常使用docker的时候，每次编写完dockerfile都要打包上传到服务器编译调试，非常的不方便，于是这里记录一个简便的办法，希望大家能有所收获 Jetbrains家的IDE都有一个插件名叫Docker，首先确保您正在使用的IDE安装Docker，这是前提。安装好此插件之后，我们的教程才刚开始。 1. Docker开启远程支持Docker默认是不开启远程支持的，我们需要对Docker服务做一些设置，以便IDE能够与其交互。这里以Ubuntu 1804.3 LTS为例，演示如何开启远程支持。 检查 /etc/systemd/system/docker.service.d/ 文件夹是否存在，如果没有则创建之。 在文件夹 /etc/systemd/system/docker.service.d/ 下新建文件override.conf，内容如下： 12345678910111213[Service]ExecStart&#x3D;ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sockExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPIDTimeoutSec&#x3D;0RestartSec&#x3D;2Restart&#x3D;always 编辑完配置文件，肯定是要重新启动一下服务以使其生效，这是常理。 systemctl daemon-reload &amp;&amp; systemctl restart docker.service 警告：以此方法开启远程支持只是为了日常开发调试方便，切莫在生产服务器打开此配置项，危险！ 2. 使用IDE连接&nbsp;&nbsp;&nbsp;&nbsp;打开IDE的设置，搜索docker","categories":[{"name":"编程","slug":"programming","permalink":"http://wangbohan2000.github.io/categories/programming/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://wangbohan2000.github.io/tags/IDE/"},{"name":"开发环境","slug":"开发环境","permalink":"http://wangbohan2000.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]},{"title":"记泳池派对","slug":"记泳池派对","date":"2019-07-07T10:05:20.000Z","updated":"2020-08-11T12:36:05.823Z","comments":true,"path":"2019/07/07/记泳池派对/","link":"","permalink":"http://wangbohan2000.github.io/2019/07/07/%E8%AE%B0%E6%B3%B3%E6%B1%A0%E6%B4%BE%E5%AF%B9/","excerpt":"","text":"记泳池派对&nbsp;&nbsp;&nbsp;&nbsp;夏天太热了，来一场泳池派对吧！","categories":[{"name":"生活","slug":"生活","permalink":"http://wangbohan2000.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://wangbohan2000.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"TCP可靠在哪？","slug":"TCP可靠在哪？","date":"2019-05-12T05:33:44.000Z","updated":"2020-08-12T10:36:17.565Z","comments":true,"path":"2019/05/12/TCP可靠在哪？/","link":"","permalink":"http://wangbohan2000.github.io/2019/05/12/TCP%E5%8F%AF%E9%9D%A0%E5%9C%A8%E5%93%AA%EF%BC%9F/","excerpt":"","text":"TCP可靠在哪？&nbsp;&nbsp;&nbsp;&nbsp;众所周知，TCP是一个面向连接的、基于流的、端到端的、可靠数据传输协议。那么，TCP究竟是如何确保数据传输的可靠性呢？ &nbsp;&nbsp;&nbsp;&nbsp;注意：可靠传输不意味着数据安全，数据在传输中仍有被篡改数据并修改checksum的可能！ checksum&nbsp;&nbsp;&nbsp;&nbsp;checksum由发送方计算，接收方用其来检验数据是否完整。把伪首部(IP头部分)、TCP包头，TCP数据分为16位的字，如果总长度为奇数个字节，则在其最后补充一个值都为0的字节。在TCP报头中把校验和字段置为0，用反码相加法累加所有的字，最后取反作为TCP校验和。 &nbsp;&nbsp;&nbsp;&nbsp;注意：checksum是不可逆的操作，所以，如果接收方验证checksum失败，则数据包一定不可靠，但是如果接收方验证checksum成功，数据包也不一定就是可靠的。 确认应答与序列号&nbsp;&nbsp;&nbsp;&nbsp;TCP协议将数据给每个字节都分配一个唯一的、递增的序列号(sequence number 16 bit)，这个机制非常重要，接收方可以通过序列号进行去重，拒绝接受重复数据。确认应答机制是指接收方收到TCP包之后，会向发送方回传一个带有ACK标志位的TCP包，告诉发送方自己收到了哪些数据。 超时重传&nbsp;&nbsp;&nbsp;&nbsp;TCP每发送一部分数据之后都要接受ACK包以确认是否发送成功。那么在这个交互的过程中，如果发送方没有接收到ACK是否要一直阻塞下去呢？没有收到ACK包可能是在发送数据的过程中数据包丢失了，也有可能是在返回的过程中ACK包丢失了。这个时候TCP的超时重传机制发挥作用，在等待一个最大超时时间之后，TCP将重新发送刚才丢失的数据包，如果该数据包是因为第一个原因丢失的，则接收方重新接受，若成功就返回ACK，若数据包丢失的愿意是第二种，则接收方利用sequence number去重，丢掉该数据包，直接返回ACK。那具体要等待多长时间之后进行超时重传呢？一般来讲操作系统会有一个初始值，然后会以初始值的x次方作为最大超时时间，x表示当前重传次数。累计达到一定的重传次数，操作系统就会认为网络状况太差，强行中断连接。 连接管理&nbsp;&nbsp;&nbsp;&nbsp;通俗的讲，连接管理就是我们耳熟能详的三次握手和四次挥手。 &nbsp;&nbsp;&nbsp;&nbsp;相信这种讲TCP握手的图，大家没少见。这里就不细说了，主要讲为什么需要三次，第三次存在的必要。举个很简单的例子，如果女神给你发消息，国际标准，一句“在吗？”，你非常高兴，回她一句“我在！”。这个时候问题出现了，如果她就此不发消息，你是否会怀疑可能因为网络状况她根本就没收到你的回复。这就是问题的关键，第三次握手就是对确认的确认，让接收方也“心安”。 &nbsp;&nbsp;&nbsp;&nbsp;再来看四次挥手，同样具体步骤其实非常简单，那么为什么挥手需要四次呢？其实道理也非常简单，当服务器收到客户端的FIN之后，只能说明什么？说明客户端想走。但是服务器想不想让它走呢？这得取决于服务有没有完成，如果缓冲区中还有数据，那么要不要发呢？答案是肯定的。所以客户端是想走就走，可服务器做事稳重，需要考虑很多东西，等处理完善了，才想客户端发送FIN。完成挥手。 流量控制&nbsp;&nbsp;&nbsp;&nbsp;现实中网络受很多因素干扰，不同的网卡，不同的网络环境，都可能会影响到网速。而接收方与发送方之间带宽的不匹配是一个很大的问题，如果发送方带宽很大，接收方来不及收怎么办？这就引入了滑动窗口协议。接收方在接受完一个TCP包之后，所返回的ACK报文中会携带滑动窗口的大小，这个大小一般是接收方缓冲区的剩余大小。发送方发送数据包之前会先发一个窗口探测的包。根据对方窗口余量进行数据放松，做到双方带宽匹配。为了避免流量控制引发的死锁，TCP使用了持续计时器。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。 拥塞控制&nbsp;&nbsp;&nbsp;&nbsp;TCP为了在传输中避免网络拥堵，采取了一种试探的技术，以比较智能的方法规避拥堵，这就是拥塞控制的手段。在刚开始发送的时候将发送窗口定义为1，拥塞窗口为1意味着当前每发送1个包就需要收到应答，之后每收到一次ACK，就将这个值乘2，每超时重传一次就将这个值减半，这就是所谓的“慢开始”。拥塞控制还引入“快重传”的概念以提高吞吐量。快重传要求接收方在收到一个失序的报文段后就立即发出重复确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文，而不必继续等待设置的重传计时器时间到期。","categories":[],"tags":[]},{"title":"动态规划就是1+1","slug":"动态规划就是1-1","date":"2019-05-09T10:31:02.000Z","updated":"2020-08-12T10:33:04.374Z","comments":true,"path":"2019/05/09/动态规划就是1-1/","link":"","permalink":"http://wangbohan2000.github.io/2019/05/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%B0%B1%E6%98%AF1-1/","excerpt":"","text":"动态规划就是1+11 - 什么是动态规划？&nbsp;&nbsp;&nbsp;&nbsp;首先引用一下Wikipedia的词条，我们来认识一下动态规划。 Dynamic programming is both a mathematical optimization method and a computer programming method. The method was developed by Richard Bellman in the 1950s and has found applications in numerous fields, from aerospace engineering to economics. In both contexts it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner. While some decision problems cannot be taken apart this way, decisions that span several points in time do often break apart recursively. Likewise, in computer science, if a problem can be solved optimally by breaking it into sub-problems and then recursively finding the optimal solutions to the sub-problems, then it is said to have optimal substructure. If sub-problems can be nested recursively inside larger problems, so that dynamic programming methods are applicable, then there is a relation between the value of the larger problem and the values of the sub-problems.[1] In the optimization literature this relationship is called the Bellman equation. &nbsp;&nbsp;&nbsp;&nbsp;其中最重要的一句话是”it refers to simplifying a complicated problem by breaking it down into simpler sub-problems in a recursive manner.”。意思是“动态规划使用递归的方式将一个复杂的问题分解为更简单的子问题解决问题。”。乍一听，感觉动态规划比较晦涩，像是个深奥的数学问题。其实，我们每天都在接触动态规划。给大家举个栗子，我们在计算1 + 1的时候，脑子条件反射般的算出答案，没错，等于2。但是当我们算1 + 1 + 1 + 1的时候，大家就会算得1 + 1 = 2，然后2 + 1 = 3， 最后3 + 1 = 4，这也正是是乘法的本质。动态规划的原理也不过如此，将复杂的问题分解为简单的子问题。 &nbsp;&nbsp;&nbsp;&nbsp;我们通过这个例子，不难发现其中几个需要注意的点。第一，做这个”1+1”难题的时候，最重要的是什么？是我们知道后一项等于前一项加一，所以我们发现，动态规划不仅仅是将大问题化简为小问题，在这其中有一个必要条件，那就是大问题和子问题之间的关系，我们把它叫做“状态转移“。在此例中，状态转移的规律非常明显。a[n] = a[n-1] + 1。我们把这种状态转移的公式化描述叫做状态转移方程。第二个需要注意的点也很容易找到，我们总是用前一项推导后一项的值，那么最前面的一项用什么来推导呢？答案是无法推到。那么我们指定一个初始值，方能使用状态转移方程推导复杂问题，我们管这个初始值叫做初始状态。这有点类似于虹吸原理。可能大家都有过这样的经历，水缸里有一缸水，我们要将其排出，那最简单的办法是什么呢？让其利用虹吸原理自动流出来，那最核心的步骤就是，我们首先需要在管子的一头用嘴巴吸出第一口水，给其一个初始动能。这就是初始状态的意义。 2 - 斐波那契数列和动态规划的渊源&nbsp;&nbsp;&nbsp;&nbsp;众所周知，斐波那契的定义是a[n] = a[n-1] + a[n-2]，我们能很明显的发现其中的一项是由前两项的和组成的。那么这不久刚好匹配了动态规划的定义吗？我们来尝试使用动态规划的思想求解斐波那契数列，感受一下动态规划为什么高效。 123456789101112131415161718public static int fib(int n) &#123; // 边界检查 if (n &lt;= 0) throw new IllegalArgumentException(&quot;n 必须大于0&quot;); if (n &lt;= 2) return n; // 确定状态 (开一个数组，明确数组的索引和值之间的对应关系 例如: 第i个元素表示fib(i)) int[] dp = new int[n]; // 初始状态 dp[0] = 1; dp[1] = 1; // 状态转移 for (int i = 2; i &lt; n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n - 1]; &#125; &nbsp;&nbsp;&nbsp;&nbsp;在我们实践中发现，还有两个步骤是必不可少的，边界检查和确定状态，确定不了状态无法用程序表示出状态转移方程，没有边界检查，我们就无法保证程序正确运行。所以这四个步骤，就是动态规划的全部。用班主任的口吻来讲，动态规划是万变不离其宗！ 3 - 实践出真知&nbsp;&nbsp;&nbsp;&nbsp;我们通过几个例子，来巩固一下动态规划的解题思路。 70. 爬楼梯&nbsp;&nbsp;&nbsp;&nbsp;印象非常深刻，这是美团曾经的一道笔试题，属于非常简单的入门题了。跟斐波那契数列一个接替思路，唯一要注意的是初始状态的界定。 123456789101112131415161718public int climbStairs(int n) &#123; // 边界检查 if(n &lt;= 0) return 0; if(n &gt; 0 &amp;&amp; n &lt;= 2) return n; // 确定状态 int[] dp = new int[n]; // 初始状态 dp[0] = 1; dp[1] = 2; // FBI WARNING !!! for(int i = 2; i &lt; n; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n - 1];&#125; 300. 最长上升子序列&nbsp;&nbsp;&nbsp;&nbsp;这道题的难点在于如何找到状态转移方程，这也是绝大多数动态规划题目的难点，我们对此进行分析。首先要确定状态，我们的dp数组究竟表示什么？一般来讲，题目的结果是什么，dp数组的值就是什么，然后再去找索引对应的含义，这是个阅读理解题……。”dp[i]表示以nums[i]结尾的LIS的长度“，这就是我们这道题中状态的含义，我们待会以此推出状态转移方程。 123456789101112131415161718public int longestCommonSubsequence(String text1, String text2) &#123; int m = text1.length(), n = text2.length(); // dp[i][j] 表示： 字符串 str1[0:i] 和字符串 str2[0:j] 的最大公共子序列 int[][] dp = new int[m+1][n+1]; // 进行状态转移 for(int i = 1; i &lt;= m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; if(text1.charAt(i-1) == text2.charAt(j-1))&#123; // 若两个字符相等，必然可以构成子问题的最优解 // 这个字符存在于 lcs 之中 dp[i][j] = dp[i-1][j-1] + 1; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[m][n]; &#125; 动态规划的题目还有很多，例如求最值，博弈等，最大的难点就是找状态转移方程，只有多刷题才能够完全掌握，学得基本原理之后，接下来就是联系啦！","categories":[{"name":"编程","slug":"programming","permalink":"http://wangbohan2000.github.io/categories/programming/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wangbohan2000.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://wangbohan2000.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"二叉树的序列化与反序列化","slug":"二叉树的序列化与反序列化","date":"2018-10-11T09:27:36.000Z","updated":"2020-08-11T12:36:37.673Z","comments":true,"path":"2018/10/11/二叉树的序列化与反序列化/","link":"","permalink":"http://wangbohan2000.github.io/2018/10/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"二叉树的序列化与反序列化前言&nbsp;&nbsp;&nbsp;&nbsp;几个月前，笔者参加了一次面试。面试的最后，面试官要求手写“二叉树的序列化与反序列化”。其实我们在掌握了二叉树的算法套路之后，这应该是比较简单的一道题。接下来我们就来看看如何解决它吧！ 讲讲序列化&nbsp;&nbsp;&nbsp;&nbsp;序列化。一个经常出现的名词，我们都知道Java Bean一般都需要继承Serializable接口，还需要定义一个serialVersionUID。新多人虽这么用过却不知道为什么要这么用。所以为了照顾新人，我们先来讲讲序列化是什么，以及为什么需要序列化。 &nbsp;&nbsp;&nbsp;&nbsp;首先引用Wikipedia的一段描述 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。 &nbsp;&nbsp;&nbsp;&nbsp;我想维基百科已经解释的非常详细了，那我们想想，为什么需要序列化呢？我们知道序列化可以将一个对象”存起来”，那么，我们就可以运行时动态的对象进行网络传输、跨平台存储、转储、RPC等操作。序列化技术可以说是很多技术的祭奠，我们耳熟能详的RPC就是其中一个。 二叉树与序列化&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经对序列化有了一个基本的了解。我们不妨思考一下序列化的过程。我们会发现，将一个数组对象序列化很简单，我们可以将 int[] arr = new int[3];序列化成”0,0,0”。将一个对象序列化也很简单，譬如JSON，就是最好的对象描述格式之一。那二叉树该怎么序列化呢？我们怎样把一个二维的“树”转换成一个一围的“串”呢? &nbsp;&nbsp;&nbsp;&nbsp;这就需要用到二叉树的遍历,一说到遍历大家就会觉得序列化也没那么难了,因为都知道二叉树的遍历是比较死板的.那么究竟选用前序还是中序,或者后序遍历呢?答案是”随便”。我们只需要保证序列化和反序列化用的是同一种遍历方法即可。那么接下来，我们就借着Leetcode中的297. 二叉树的序列化与反序列化来给大家演示一下序列化与反序列化操作。 &nbsp;&nbsp;&nbsp;&nbsp;首先还是回顾一下遍历操作，三种不同的遍历方式区别只在于逻辑代码和递归代码的相对位置。我们就以前序遍历来演示。 12345678910// 二叉树前序遍历套路。public static void preOrder(TreeNode root)&#123; if( root == null ) return; // 前序遍历 逻辑代码 doSomething(); preOrder(root.left); preOrder(root.right);&#125; &nbsp;&nbsp;&nbsp;&nbsp;基于这个骨架，我们来看看二叉树的序列化代码应该怎么写。按照我们刚才的框架，我们首先应该想到的代码是这样的。 123456789101112131415161718class Codec &#123; final String NULL = &quot;null&quot;; // 用&#x27;null&#x27;代替表示空节点; final String SEP = &quot;,&quot;; StringBuilder res = new StringBuilder(); public void serialize(TreeNode root) &#123; if ( root == null ) &#123; res.append(NULL); res.append(SEP); &#125; else &#123; res.append(String.valueOf(root.val)); res.append(SEP); serialize(root.left); serialize(root.right); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;但是我们会发现，明明一个简单的递归，写出来却很复杂。而且力扣297给的方法签名是这个样子的。String serialize(TreeNode root)。那这样一变，可能萌新们变得无从下手，不会套框架了。我们来看看怎样在递归中正确的返回我们想要的结果。 1234public String serialize(TreeNode root) &#123; if (root == null) return NULL; return String.valueOf(root.val) + SEP + serialize(root.left) + SEP + serialize(root.right); &#125; &nbsp;&nbsp;&nbsp;&nbsp;至此，我们得到的字符串类似于 “1,2,null,null,3,null,null” &nbsp;&nbsp;&nbsp;&nbsp;相对序列化来说，反序列化稍微麻烦一点，因为方法需要返回一个TreeNode节点，所以我们在一个方法中是无法完成递归添加元素并返回的。这时候我们就需要一个辅助方法来独立地完成递归，在另一个方法中返回。 1234567891011121314151617TreeNode helper(List&lt;String&gt; strs) &#123; if (strs.get(0).equals(NULL)) &#123; strs.remove(0); return null; &#125; TreeNode root = new TreeNode(Integer.parseInt(strs.get(0))); strs.remove(0); root.left = helper(strs); root.right = helper(strs); return root; &#125; public TreeNode deserialize(String data) &#123; String[] data_array = data.split(&quot;,&quot;); List&lt;String&gt; data_list = new ArrayList&lt;&gt;(Arrays.asList(data_array)); return helper(data_list); &#125; &nbsp;&nbsp;&nbsp;&nbsp;这么一看，二叉树的序列化与反序列化是不是很简单呢？但是其实这里面有一个非常重要的前提条件，那就是”null”。有的题目会给一个字符串，但是其中的空元素并没有用null标识，或者有其他的题目变种，一般来说，我们都很难从字符串直接构造出二叉树结构。需要通过两种不同的遍历方式确定root节点的位置。但总体来说难度不算很大，这里给大家留一个作业，看看自己是否可以举一反三，对Leetcode此类题做一个集中训练，将变种题目也收入囊中。 &nbsp;&nbsp;&nbsp;&nbsp;Bye ~","categories":[{"name":"编程","slug":"programming","permalink":"http://wangbohan2000.github.io/categories/programming/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wangbohan2000.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"http://wangbohan2000.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}],"categories":[{"name":"编程","slug":"programming","permalink":"http://wangbohan2000.github.io/categories/programming/"},{"name":"生活","slug":"生活","permalink":"http://wangbohan2000.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://wangbohan2000.github.io/tags/IDE/"},{"name":"开发环境","slug":"开发环境","permalink":"http://wangbohan2000.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"生活","slug":"生活","permalink":"http://wangbohan2000.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"算法","slug":"算法","permalink":"http://wangbohan2000.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://wangbohan2000.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二叉树","slug":"二叉树","permalink":"http://wangbohan2000.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]}