{"meta":{"title":"WBHAN","subtitle":"Coding is fantistic!","description":"Coding is fantistic, so I should record it.","author":"Bohan Wang","url":"http://wangbohan2000.github.io","root":"/"},"pages":[{"title":"","date":"2020-08-11T06:45:43.255Z","updated":"2020-08-11T06:45:43.255Z","comments":true,"path":"404.html","permalink":"http://wangbohan2000.github.io/404.html","excerpt":"","text":""},{"title":"categories","date":"2020-08-11T06:26:49.000Z","updated":"2020-08-11T10:20:33.246Z","comments":false,"path":"categories/index.html","permalink":"http://wangbohan2000.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-11T06:24:31.000Z","updated":"2020-08-11T10:20:33.247Z","comments":false,"path":"tags/index.html","permalink":"http://wangbohan2000.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记泳池派对","slug":"记泳池派对","date":"2020-08-11T10:33:06.000Z","updated":"2020-08-11T10:40:46.661Z","comments":true,"path":"2020/08/11/记泳池派对/","link":"","permalink":"http://wangbohan2000.github.io/2020/08/11/%E8%AE%B0%E6%B3%B3%E6%B1%A0%E6%B4%BE%E5%AF%B9/","excerpt":"","text":"记泳池派对&nbsp;&nbsp;&nbsp;&nbsp;夏天太热了，来一场泳池派对吧！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://wangbohan2000.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"二叉树的序列化与反序列化","slug":"二叉树的序列化与反序列化","date":"2020-08-11T09:27:36.000Z","updated":"2020-08-11T10:20:33.241Z","comments":true,"path":"2020/08/11/二叉树的序列化与反序列化/","link":"","permalink":"http://wangbohan2000.github.io/2020/08/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"二叉树的序列化与反序列化前言&nbsp;&nbsp;&nbsp;&nbsp;几个月前，笔者参加了一次面试。面试的最后，面试官要求手写“二叉树的序列化与反序列化”。其实我们在掌握了二叉树的算法套路之后，这应该是比较简单的一道题。接下来我们就来看看如何解决它吧！ 讲讲序列化&nbsp;&nbsp;&nbsp;&nbsp;序列化。一个经常出现的名词，我们都知道Java Bean一般都需要继承Serializable接口，还需要定义一个serialVersionUID。新多人虽这么用过却不知道为什么要这么用。所以为了照顾新人，我们先来讲讲序列化是什么，以及为什么需要序列化。 &nbsp;&nbsp;&nbsp;&nbsp;首先引用Wikipedia的一段描述 序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。 &nbsp;&nbsp;&nbsp;&nbsp;我想维基百科已经解释的非常详细了，那我们想想，为什么需要序列化呢？我们知道序列化可以将一个对象”存起来”，那么，我们就可以运行时动态的对象进行网络传输、跨平台存储、转储、RPC等操作。序列化技术可以说是很多技术的祭奠，我们耳熟能详的RPC就是其中一个。 二叉树与序列化&nbsp;&nbsp;&nbsp;&nbsp;现在我们已经对序列化有了一个基本的了解。我们不妨思考一下序列化的过程。我们会发现，将一个数组对象序列化很简单，我们可以将 int[] arr = new int[3];序列化成”0,0,0”。将一个对象序列化也很简单，譬如JSON，就是最好的对象描述格式之一。那二叉树该怎么序列化呢？我们怎样把一个二维的“树”转换成一个一围的“串”呢? &nbsp;&nbsp;&nbsp;&nbsp;这就需要用到二叉树的遍历,一说到遍历大家就会觉得序列化也没那么难了,因为都知道二叉树的遍历是比较死板的.那么究竟选用前序还是中序,或者后序遍历呢?答案是”随便”。我们只需要保证序列化和反序列化用的是同一种遍历方法即可。那么接下来，我们就借着Leetcode中的297. 二叉树的序列化与反序列化来给大家演示一下序列化与反序列化操作。 &nbsp;&nbsp;&nbsp;&nbsp;首先还是回顾一下遍历操作，三种不同的遍历方式区别只在于逻辑代码和递归代码的相对位置。我们就以前序遍历来演示。 12345678910// 二叉树前序遍历套路。public static void preOrder(TreeNode root)&#123; if( root == null ) return; // 前序遍历 逻辑代码 doSomething(); preOrder(root.left); preOrder(root.right);&#125; &nbsp;&nbsp;&nbsp;&nbsp;基于这个骨架，我们来看看二叉树的序列化代码应该怎么写。按照我们刚才的框架，我们首先应该想到的代码是这样的。 123456789101112131415161718class Codec &#123; final String NULL = &quot;null&quot;; // 用&#x27;null&#x27;代替表示空节点; final String SEP = &quot;,&quot;; StringBuilder res = new StringBuilder(); public void serialize(TreeNode root) &#123; if ( root == null ) &#123; res.append(NULL); res.append(SEP); &#125; else &#123; res.append(String.valueOf(root.val)); res.append(SEP); serialize(root.left); serialize(root.right); &#125; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;但是我们会发现，明明一个简单的递归，写出来却很复杂。而且力扣297给的方法签名是这个样子的。String serialize(TreeNode root)。那这样一变，可能萌新们变得无从下手，不会套框架了。我们来看看怎样在递归中正确的返回我们想要的结果。 1234public String serialize(TreeNode root) &#123; if (root == null) return NULL; return String.valueOf(root.val) + SEP + serialize(root.left) + SEP + serialize(root.right); &#125; &nbsp;&nbsp;&nbsp;&nbsp;至此，我们得到的字符串类似于 “1,2,null,null,3,null,null” &nbsp;&nbsp;&nbsp;&nbsp;相对序列化来说，反序列化稍微麻烦一点，因为方法需要返回一个TreeNode节点，所以我们在一个方法中是无法完成递归添加元素并返回的。这时候我们就需要一个辅助方法来独立地完成递归，在另一个方法中返回。 1234567891011121314151617TreeNode helper(List&lt;String&gt; strs) &#123; if (strs.get(0).equals(NULL)) &#123; strs.remove(0); return null; &#125; TreeNode root = new TreeNode(Integer.parseInt(strs.get(0))); strs.remove(0); root.left = helper(strs); root.right = helper(strs); return root; &#125; public TreeNode deserialize(String data) &#123; String[] data_array = data.split(&quot;,&quot;); List&lt;String&gt; data_list = new ArrayList&lt;&gt;(Arrays.asList(data_array)); return helper(data_list); &#125; &nbsp;&nbsp;&nbsp;&nbsp;这么一看，二叉树的序列化与反序列化是不是很简单呢？但是其实这里面有一个非常重要的前提条件，那就是”null”。有的题目会给一个字符串，但是其中的空元素并没有用null标识，或者有其他的题目变种，一般来说，我们都很难从字符串直接构造出二叉树结构。需要通过两种不同的遍历方式确定root节点的位置。但总体来说难度不算很大，这里给大家留一个作业，看看自己是否可以举一反三，对Leetcode此类题做一个集中训练，将变种题目也收入囊中。 &nbsp;&nbsp;&nbsp;&nbsp;Bye ~","categories":[{"name":"编程","slug":"programming","permalink":"http://wangbohan2000.github.io/categories/programming/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://wangbohan2000.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"http://wangbohan2000.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"Jetbrains系列IDE配合Docker插件自动部署","slug":"Jetbrains系列IDE配合Docker插件自动部署","date":"2020-08-11T03:33:11.000Z","updated":"2020-08-11T10:20:33.241Z","comments":true,"path":"2020/08/11/Jetbrains系列IDE配合Docker插件自动部署/","link":"","permalink":"http://wangbohan2000.github.io/2020/08/11/Jetbrains%E7%B3%BB%E5%88%97IDE%E9%85%8D%E5%90%88Docker%E6%8F%92%E4%BB%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","excerpt":"","text":"Jetbrains系列IDE配合Docker插件自动部署&nbsp;&nbsp;&nbsp;&nbsp;docker大大简化了部署的复杂度，可是大家日常使用docker的时候，每次编写完dockerfile都要打包上传到服务器编译调试，非常的不方便，于是这里记录一个简便的办法，希望大家能有所收获 Jetbrains家的IDE都有一个插件名叫Docker，首先确保您正在使用的IDE安装Docker，这是前提。安装好此插件之后，我们的教程才刚开始。 1. Docker开启远程支持Docker默认是不开启远程支持的，我们需要对Docker服务做一些设置，以便IDE能够与其交互。这里以Ubuntu 1804.3 LTS为例，演示如何开启远程支持。 检查 /etc/systemd/system/docker.service.d/ 文件夹是否存在，如果没有则创建之。 在文件夹 /etc/systemd/system/docker.service.d/ 下新建文件override.conf，内容如下： 12345678910111213[Service]ExecStart&#x3D;ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd -H tcp:&#x2F;&#x2F;0.0.0.0:2375 -H unix:&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sockExecReload&#x3D;&#x2F;bin&#x2F;kill -s HUP $MAINPIDTimeoutSec&#x3D;0RestartSec&#x3D;2Restart&#x3D;always 编辑完配置文件，肯定是要重新启动一下服务以使其生效，这是常理。 systemctl daemon-reload &amp;&amp; systemctl restart docker.service 警告：以此方法开启远程支持只是为了日常开发调试方便，切莫在生产服务器打开此配置项，危险！ 2. 使用IDE连接&nbsp;&nbsp;&nbsp;&nbsp;打开IDE的设置，搜索docker","categories":[{"name":"编程","slug":"programming","permalink":"http://wangbohan2000.github.io/categories/programming/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://wangbohan2000.github.io/tags/IDE/"},{"name":"开发环境","slug":"开发环境","permalink":"http://wangbohan2000.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]}],"categories":[{"name":"编程","slug":"programming","permalink":"http://wangbohan2000.github.io/categories/programming/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://wangbohan2000.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"算法","slug":"算法","permalink":"http://wangbohan2000.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二叉树","slug":"二叉树","permalink":"http://wangbohan2000.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"IDE","slug":"IDE","permalink":"http://wangbohan2000.github.io/tags/IDE/"},{"name":"开发环境","slug":"开发环境","permalink":"http://wangbohan2000.github.io/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]}